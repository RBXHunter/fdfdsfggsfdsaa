-- SERVICES
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local ROCKS = workspace:WaitForChild("Rocks")
local DISTANCE = 20
local UPDATE_INTERVAL = 0.5

local running = true
local espCache = {}

-- ===== UTIL =====

local function getBasePart(model)
	return model:FindFirstChildWhichIsA("BasePart", true)
end

local function isValidRock(model)
	if not model:IsA("Model") then return false end
	if not getBasePart(model) then return false end

	for _, child in ipairs(model:GetChildren()) do
		if child:IsA("Model") and child:GetAttribute("Ore") then
			return true
		end
	end

	return false
end

local function getRockText(rock)
	local counts = {}

	for _, ore in ipairs(rock:GetChildren()) do
		if ore:IsA("Model") then
			local oreName = ore:GetAttribute("Ore")
			if oreName then
				counts[oreName] = (counts[oreName] or 0) + 1
			end
		end
	end

	local lines = {}
	for name, count in pairs(counts) do
		table.insert(lines, name .. " x" .. count)
	end

	if #lines == 0 then
		return nil
	end

	return table.concat(lines, "\n")
end

-- ===== ESP =====

local function removeESP(rock)
	if espCache[rock] then
		espCache[rock]:Destroy()
		espCache[rock] = nil
	end
end

local function createESP(rock)
	local text = getRockText(rock)
	if not text then
		removeESP(rock)
		return
	end

	local part = getBasePart(rock)
	if not part then return end

	if espCache[rock] then
		espCache[rock].TextLabel.Text = text
		return
	end

	local gui = Instance.new("BillboardGui")
	gui.Name = "OreESP"
	gui.Adornee = part
	gui.Size = UDim2.new(0, 180, 0, 60)
	gui.StudsOffset = Vector3.new(0, 3, 0)
	gui.AlwaysOnTop = true

	local label = Instance.new("TextLabel")
	label.Name = "TextLabel"
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.TextWrapped = true
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextColor3 = Color3.fromRGB(255, 200, 100)
	label.TextStrokeTransparency = 0
	label.Text = text
	label.Parent = gui

	gui.Parent = part
	espCache[rock] = gui
end

-- ===== GUI =====

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OreESP_GUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 130, 0, 40)
button.Position = UDim2.new(0, 20, 0, 20)
button.Text = "Kill Script"
button.Font = Enum.Font.PermanentMarker
button.TextSize = 30
button.TextColor3 = Color3.fromRGB(0,0,0)
button.TextStrokeColor3 = Color3.fromRGB(0,0,0)
button.TextStrokeTransparency = 0
button.BackgroundColor3 = Color3.fromRGB(255,255,255)
button.Parent = screenGui

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 10)
uicorner.Parent = button

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255,0,0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200,200,200)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0,0,255))
}
gradient.Parent = button

button.MouseButton1Click:Connect(function()
	running = false
	for _, gui in pairs(espCache) do
		gui:Destroy()
	end
	espCache = {}
	screenGui:Destroy()
end)

-- ===== MAIN LOOP =====

task.spawn(function()
	while running do
		for _, island in ipairs(ROCKS:GetChildren()) do
			for _, rock in ipairs(island:GetChildren()) do
				if isValidRock(rock) then
					local part = getBasePart(rock)
					if part and (hrp.Position - part.Position).Magnitude <= DISTANCE then
						createESP(rock)
					else
						removeESP(rock)
					end
				else
					removeESP(rock)
				end
			end
		end
		task.wait(UPDATE_INTERVAL)
	end
end)

-- ===== DYNAMIC ORE SPAWN =====

for _, island in ipairs(ROCKS:GetChildren()) do
	island.DescendantAdded:Connect(function(child)
		if not running then return end
		if child:IsA("Model") and child:GetAttribute("Ore") then
			local rock = child.Parent
			if rock and isValidRock(rock) then
				local part = getBasePart(rock)
				if part and (hrp.Position - part.Position).Magnitude <= DISTANCE then
					createESP(rock)
				end
			end
		end
	end)
end
